import { Request, Response } from "express";
import Playlist, { PlaylistDoc, PlaylistObjFromQuery, findById as findPlaylistById } from "../../database/models/playlist";
import { Song, SongApiObj, SongObj } from "../../types/song";
import { print } from "../util/util";
import internalErrorHandler from "../errorHandlers/internalErrorHandler";
import notFoundErrorHandler from "../errorHandlers/notFoundErrorHandler";
import { mongoose } from "../../database/connection";
import { PlayAudioLink, SelfLink, PatchLink } from "../../types/link";
import { PlaylistApiObj } from "../../types/playlist";
import accessDeniedErrorHandler from "../errorHandlers/accessDeniedErrorHandler";
import { getUserFromToken, getUserIdFromToken } from "../auth/getUser";
import axios from "axios";
import getGeneratedPlaylist from "../spotify/getGeneratedPlaylist";
import resolveSpotifySongs from "../util/resolveSongs";
import { cacheSongFromSong } from "../util/cacheSong";
import { SongModelFromSong } from "../../database/models/song";

const sendPlaylistResponse = (playlistResults: PlaylistDoc[], req: Request, res:Response, userId?: string) => {
	const noRender = !!req.query.noRender;

	const playlists = playlistResults.map(async result => {
		const playlist = await PlaylistObjFromQuery(result, !noRender);

		playlist.songs = playlist.songs.map(song => new SongApiObj(song, [
			new PlayAudioLink(req, song),
			new SelfLink(req, song.id ?? "UNKNOWN", "songs")
		]));

		const links = [new SelfLink(req, result._id, "playlists")];
		if (userId && playlist.details?.user === userId) {
			links.push(new PatchLink(req, result._id, "playlists"));
		}

		return new PlaylistApiObj(
			playlist,
			links
		);
	});

	Promise.all(playlists).then(playlistResolved => {
		res.send({
			playlists: playlistResolved
		});
		res.end();
	}).catch(internalErrorHandler(req, res));
};

const getPlaylists = (req: Request, res: Response): void => {
	print(`Handling request for playlist resources`);

	const isNamed = !!req.query.isNamed;
	const noAutoGenerated = !!req.query.noAutoGenerated;

	let total: PlaylistDoc[] = [];
	let userId: string | undefined;
	Playlist.find({
		private: false
	}).then(playlistResults => {
		total = [...playlistResults];
		return new Promise<PlaylistDoc[]>((resolve, reject) => {
			getUserIdFromToken(req.header("token") ?? "INVALID").then(user => {
				userId = user;
				Playlist.find({
					user: new mongoose.Types.ObjectId(user)
				}).then(resolve).catch(reject);
			}).catch(() => {
				resolve(Promise.resolve([]));
			});
		});
	}).then(playlistResults => {
		total = [...total, ...playlistResults];
		total = total.filter((v, i, a) => a.findIndex(t => (t.id === v.id)) === i);

		if (isNamed) {
			total = total.filter(p => !!(p.name));
		}

		if (total && total.length) {
			if (noAutoGenerated) {
				total = total.filter(playlist => !playlist.autoGenerated);
			}
			sendPlaylistResponse(total, req, res, userId);
		} else {
			notFoundErrorHandler(req, res)("playlist");
		}
	}).catch(internalErrorHandler(req, res));
};

const getPlaylist = (req: Request, res: Response): void => {
	print(`Handling request for playlist resource ${req.params.id}`);
	findPlaylistById(req.params.id).then(playlistResults => {
		if (playlistResults) {
			getUserIdFromToken(req.header("token") ?? "INVALID").then(user => {
				if (!playlistResults.private || user === String(playlistResults.user)) {
					sendPlaylistResponse([playlistResults], req, res, user);
				} else {
					accessDeniedErrorHandler(req, res)(playlistResults._id);
				}
			}).catch(() => {
				if (playlistResults.private) {
					accessDeniedErrorHandler(req, res)(playlistResults._id);
				} else {
					sendPlaylistResponse([playlistResults], req, res);
				}
			});
		} else {
			notFoundErrorHandler(req, res)("playlist", req.params.id);
		}
	}).catch(internalErrorHandler(req, res));
};

const postPlaylist = (req: Request, res: Response): void => {
	print(`Handling request for playlist creation`);

	const songIds: string[] = req.body.songs;

	new Playlist({
		songs: songIds,
		name: req.body.name,
		user: req.body.user ? new mongoose.Types.ObjectId(req.body.user) : undefined,
		description: req.body.description,
		features: req.body.features,
		private: req.body.private ?? true
	}).save().then(resp => {
		print(`Created playlist resource ${resp}`);
		sendPlaylistResponse([resp], req, res);
	}).catch(internalErrorHandler(req, res));
};

const patchPlaylist = (req: Request, res: Response): void => {
	const id: string = req.params.id;
	const name: string | undefined = req.body.name;
	const songs: string[] | undefined = req.body.songs;
	const description: string | undefined = req.body.description;
	const features: string[] | undefined = req.body.features;
	const privacy: boolean | undefined = req.body.private;

	getUserIdFromToken(req.header("token") ?? "INVALID").then(userId => {
		findPlaylistById(id, userId).then(playlist => {
			if (playlist) {
				if (name) {
					playlist.name = name;
				}
				if (songs) {
					playlist.songs = songs.map(song => new mongoose.Types.ObjectId(song));
				}
				if (description) {
					playlist.description = description;
				}
				if (features) {
					playlist.features = features.map(song => new mongoose.Types.ObjectId(song));
				}
				if (privacy) {
					playlist.private = privacy;
				}
				playlist.save().then(results => {
					sendPlaylistResponse([results], req, res);
				}).catch(internalErrorHandler(req, res));
			} else {
				notFoundErrorHandler(req, res)("playlist", id);
			}
		}).catch(internalErrorHandler(req, res));
	}).catch(() => {
		accessDeniedErrorHandler(req, res)(id);
	});
};

const deletePlaylist = (req: Request, res: Response): void => {
	const id: string = req.params.id;

	getUserIdFromToken(req.header("token") ?? "INVALID").then(userId => {
		findPlaylistById(id, userId).then(playlist => {
			if (playlist) {
				playlist.delete().then(() => {
					res.status(200).json({});
				}).catch(internalErrorHandler(req, res));
			} else {
				notFoundErrorHandler(req, res)("playlist", id);
			}
		}).catch(internalErrorHandler(req, res));
	}).catch(() => {
		accessDeniedErrorHandler(req, res)(id);
	});
};

const getForMePlaylists = (req: Request, res: Response): void => {
	const entry = req.protocol + "://" + req.get("host");

	getUserFromToken(req.header("token") as string).then(user => {
		axios.post(`${entry}/auth/spotify`, {
			refresh_token: user.refreshToken
		}, {
			headers: {
				token: req.header("token")
			}
		}).then(async resp => {
			if (resp.data?.access_token) {
				const accessToken = resp.data.access_token;

				let resolvedSaved: Song[][] = [];

				Promise.all([
					getGeneratedPlaylist(accessToken, "short_term"),
					getGeneratedPlaylist(accessToken, "medium_term"),
					getGeneratedPlaylist(accessToken, "long_term")
				]).then(spotifyResults => {
					return Promise.all(spotifyResults.map(results => resolveSpotifySongs(results)));
				}).then(resolved => {
					resolvedSaved = resolved;
					return Promise.all(resolved.map(setlist => Promise.all(setlist.map(song => cacheSongFromSong(song)))));
				}).then(cached => {
					const withAudioId = resolvedSaved.map((setlist, i) => setlist.map((song, j) => new SongObj(
						song.title,
						song.artist,
						song.album,
						song.duration,
						song.explicit,
						song.spotifyId,
						song.artistSpotifyId,
						song.albumSpotifyId,
						song.youtubeId,
						song.tags,
						song.thumbnailUrl,
						song.releaseDate,
						cached[i][j]
					)
					));
					return Promise.all(withAudioId.map(setlist => Promise.all(setlist.map(song => SongModelFromSong(song).save()))));
				}).then(docs => {
					return Promise.all(docs.map((doc, i) => {
						const songs = doc.map(songDoc => String(songDoc._id));
						return new Playlist({
							songs,
							name: `Made for you #${i + 1}`,
							user: mongoose.Types.ObjectId(user.id),
							description: doc.map(songDoc => songDoc.artist).slice(0, 3).join(", "),
							features: songs.slice(0, 3).map(id => new mongoose.Types.ObjectId(id)),
							private: true,
							autoGenerated: true
						}).save();
					}));
				}).then(docs => {
					sendPlaylistResponse(docs, req, res);
				}).catch(internalErrorHandler(req, res));
			} else {
				internalErrorHandler(req, res)("Failed to retrieve access token");
			}
		}).catch(internalErrorHandler(req, res));
	}).catch(internalErrorHandler(req, res));
};

export { getPlaylists, getPlaylist, postPlaylist, patchPlaylist, deletePlaylist, getForMePlaylists };
