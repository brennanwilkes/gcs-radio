import { Request, Response } from "express";
import Playlist from "../../../database/models/playlist";
import { CONFIG } from "../../util/util";
import internalErrorHandler from "../../errorHandlers/internalErrorHandler";
import { getUserFromToken } from "../../auth/getUser";
import { getForMePlaylist } from "../../spotify/getGeneratedPlaylist";
import getUserAccessToken from "../../spotify/getUserAccessToken";
import cacheSongsFromSpotify from "../../spotify/cacheSongsFromSpotify";

import sendPlaylistResponse from "./sendPlaylistResponse";

export default (req: Request, res: Response): void => {
	const limit = (req.query.limit as number | undefined) ?? CONFIG.defaultApiLimit;

	getUserFromToken(req.header("token") as string).then(user => {
		getUserAccessToken(user.refreshToken ?? "ERROR").then(async accessToken => {
			// Getting made-for-me requires spotify authentication
			Promise.all([
				getForMePlaylist(accessToken, "short_term", limit),
				getForMePlaylist(accessToken, "medium_term", limit),
				getForMePlaylist(accessToken, "long_term", limit)
			]).then(spotifyResults => {
				// Post songs to database
				return Promise.all(spotifyResults.map(cacheSongsFromSpotify));
			}).then(songsArrs => {
				// Map each array of songs into an actual playlist
				return Promise.all(songsArrs.map((songs, i) => {
					const songIds = songs.map(song => String(song.id));
					return new Playlist({
						songs: songIds,
						name: (i === 0 ? "On The Go" : (i === 1 ? "Recent Favourites" : "Old Memories")),
						user: user.id,
						description: songs.map(song => song.artist).slice(0, 3).join(", "),
						features: songIds.slice(0, 3),
						private: true,
						autoGenerated: true
					}).save();
				}));
			}).then(docs => {
				sendPlaylistResponse(docs, req, res);
			}).catch(internalErrorHandler(req, res));
		}).catch(internalErrorHandler(req, res));
	}).catch(internalErrorHandler(req, res));
};
