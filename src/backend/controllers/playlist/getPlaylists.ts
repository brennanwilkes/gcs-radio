import { Request, Response } from "express";
import Playlist from "../../../database/models/playlist";
import { getLimit, getPage, print } from "../../util/util";
import internalErrorHandler from "../../errorHandlers/internalErrorHandler";
import notFoundErrorHandler from "../../errorHandlers/notFoundErrorHandler";
import { mongoose } from "../../../database/connection";
import { getUserIdFromToken } from "../../auth/getUser";

import sendPlaylistResponse from "./sendPlaylistResponse";

export default async (req: Request, res: Response): Promise<void> => {
	print(`Handling request for playlist resources`);

	const isNamed = !!req.query.isNamed;
	const noAutoGenerated = !!req.query.noAutoGenerated;
	const id = await getUserIdFromToken(req.header("token") ?? "INVALID").catch(() => undefined);

	const isPrivate = {
		private: false
	};
	const orQuery = id
		? {
			$or: [
				isPrivate,
				{
					private: true,
					user: new mongoose.Types.ObjectId(id)
				}
			]
		}
		: isPrivate;

	const namedQuery = isNamed
		? {
			$and: [
				orQuery,
				{ name: { $exists: true } }
			]
		}
		: orQuery;

	const query = noAutoGenerated
		? {
			$and: [
				namedQuery,
				{
					$or: [
						{
							autoGenerated: false
						},
						{
							autoGenerated: { $exists: false }
						}
					]
				}
			]
		}
		: namedQuery;

	Playlist.find(query)
		.limit(getLimit(req))
		.skip(getLimit(req) * (getPage(req) - 1))
		.populate({
			path: "songs",
			populate: { path: "song" }
		})
		.populate({
			path: "features",
			populate: { path: "song" }
		})
		.then(playlistResults => {
			if (playlistResults.length > 0) {
				sendPlaylistResponse(playlistResults, req, res, id);
			} else {
				notFoundErrorHandler(req, res)("playlist");
			}
		}).catch(internalErrorHandler(req, res));
};
