import { Request, Response } from "express";
import Playlist, { PlaylistDoc } from "../../../database/models/playlist";
import { CONFIG, print } from "../../util/util";
import internalErrorHandler from "../../errorHandlers/internalErrorHandler";
import notFoundErrorHandler from "../../errorHandlers/notFoundErrorHandler";
import { mongoose } from "../../../database/connection";
import { getUserIdFromToken } from "../../auth/getUser";

import sendPlaylistResponse from "./sendPlaylistResponse";

export default (req: Request, res: Response): void => {
	print(`Handling request for playlist resources`);

	const isNamed = !!req.query.isNamed;
	const noAutoGenerated = !!req.query.noAutoGenerated;

	// at the moment limits won't be accurate for isNamed or noAutoGenerated requests.
	// Eventually need to switch to mongo pipelines instead of straight queries
	const limit = (req.query.limit as number | undefined) ?? CONFIG.defaultApiLimit;

	let total: PlaylistDoc[] = [];
	let userId: string | undefined;

	// Get public playlists first
	Playlist.find({
		private: false
	}).limit(limit).then(playlistResults => {
		total = [...playlistResults];
		if (total.length >= limit) {
			return Promise.resolve([]);
		}
		return new Promise<PlaylistDoc[]>((resolve, reject) => {
			getUserIdFromToken(req.header("token") ?? "INVALID").then(user => {
				userId = user;

				// Get user private playlists
				Playlist.find({
					user: new mongoose.Types.ObjectId(user)
				}).limit(limit - total.length).then(resolve).catch(reject);
			}).catch(() => {
				resolve(Promise.resolve([]));
			});
		});
	}).then(playlistResults => {
		total = [...total, ...playlistResults];

		// Strip out duplicates
		total = total.filter((v, i, a) => a.findIndex(t => (t.id === v.id)) === i);

		// Remove anonymous playlists
		// Eventually should be part of a pipeline
		if (isNamed) {
			total = total.filter(p => !!(p.name));
		}

		if (total && total.length) {
			// Remove autogenerated playlists
			// Eventually should be part of a pipeline
			if (noAutoGenerated) {
				total = total.filter(playlist => !playlist.autoGenerated);
			}
			sendPlaylistResponse(total, req, res, userId);
		} else {
			notFoundErrorHandler(req, res)("playlist");
		}
	}).catch(internalErrorHandler(req, res));
};
